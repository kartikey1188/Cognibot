[Music] in the previous lectures of this week we looked at various phases and activities in the software development process we also looked at why these phases are important so learners many of you might have developed software projects before right so let's reflect on how you went about developing software you might not have strictly followed the process of identifying requirements then coming up with the design then writing code testing it and so on so you might have followed an exploratory programming style so this is commonly known as the build and fix type of programming and here programmers they typically start to write the program immediately after forming an informal understanding of the requirements and once the program is complete then they fix anything which does not match the user's expectation and this was how programming was done in the early 1950s and 60s so good programmers they knew certain principles that help them write good programs and these principles could be things like you know thinking thinking about the big picture view of the system which is the design before you actually start writing the program and over time these good principles and practices along with research innovations they have been systematically organized into what is known as software engineering today so software engineering emphasizes software development through a well-defined and ordered set of activities and these activities are commonly referred by various names such as the software lifecycle model software development lifecycle or sdlc and the software development process model so the software life cycle is the different stages the phases and activities over which a software evolves from the initial customer request to a fully developed software and we saw some of these activities in the previous lecture right so we start the development by gathering requirements which should cater to the need of the clients then we come up with a design which is a big picture view of the system then developers write code based on the requirements and the design and then we do testing and maintenance and this process is commonly known as the waterfall model or the plan and document perspective it is known as waterfall model because each of these phases occur one after the other and it is known as a plan and document perspective because before we start writing code we have to come up with a plan for the project which includes extensive detailed documentation of all the phases of that plan and progress is then measured against this plan so learners let's reflect on this question so we saw that in the waterfall model each of these phases follow one after the other so what could go wrong if we follow these phases sequentially please pause this video and think about some reasons before proceeding okay so now let's look at some of the drawbacks of the waterfall model let's say we are developing a software for a client and we talk to the client we gather requirements let's say that takes around two months then based on these requirements we come up with the big picture view the design right that takes around three months then after that we start writing code for this design that takes around four months and we test and fix bugs which takes another three months so from the time of gathering requirements till the testing phase and finally the release it takes around 12 months it takes one year to develop the entire system and we release it to the clients but unfortunately the client says that he or she doesn't like it there has been some misunderstanding regarding what the requirements are regarding certain aspects of the requirements or maybe the client changed his own mind about certain aspects of some requirements maybe they don't like the user interface right so these are some drawbacks and because of this now i have to go back and refine my requirements and start this process again so what are the drawbacks of the waterfall model one as we saw so there is an increase in cost and time if changes are required later on as we saw in this scenario second clients themselves may not know what they need so they might need to see something before they even realize what they actually need and third even the developers of the designers they might not know which design might be the most feasible or most usable by the clients and finally as we saw one phase or one iteration can take maybe six to even 18 months for one cycle to occur so these are certain drawbacks of the waterfall model so now as we have seen there are certain drawbacks of the waterfall model how can we address these issues or these disadvantages of the waterfall model can you think of some solutions please pause this video and think about some solutions before proceeding so one solution can be can we get feedback from the customers earlier on right so in this model which is known as the prototype model we build a working prototype of the system before development of the actual software and this prototype has limited functional capabilities and their performance might not be optimal compared to the actual software the advantage is that it's easier for the customers to understand what they want once they see this prototype as well as for developers and engineers to understand how to build it better once they have done it for the first time and usually the prototype it is not used later it is thrown away or new software is built so what are the advantages of the the prototype model so one it is useful when the exact form of the solution is not known and even the technical issues are unclear it is good to build a prototype and as we saw it is useful to get feedback from customers however what is the disadvantage one is that it can increase the cost of development for projects because as we saw the prototypes are not usually used later on and since we are not building the actual system so what about risks and bugs which appear later in the software development in the development cycle so the prototype model cannot capture these another solution can be to incrementally build the software right get feedback refine and this model is known as the spiral model so the spiral model it combines both the waterfall and the prototyping model and as you can see in this image there are four phases first we determine the objectives alternatives constraints for this one iteration and then we evaluate alternatives we resolve risk and then we develop and test and release the product to the client and then we plan for the next phase so at each iteration there was a refinement of the prototype compared to the previous version and unlike the waterfall model where we document everything at the beginning the requirement documents are developed across each iteration as and when they are needed and the software eventually evolves into the final product and we also involve customers at the end of every iteration and this helps in reducing misunderstandings between the client and the developers but one drawback of this model is that the iterations still take long time so it takes around 6 to 24 months for each iteration so to summarize in this video we looked at the software development life cycle which is the different activities that need to be carried out for this for software development we looked at different models in this plan and document perspective we looked at the waterfall model where each of the phases are followed sequentially then we looked at the prototype model where we build a prototype first and get feedback from users and the spiral model which combines the advantages of waterfall and the prototype model now in the next video we will be looking at the agile perspective which is a quite popular perspective nowadays to develop software and we will be using many of the principles from the agile perspective throughout the course